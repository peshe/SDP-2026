# СД на ИС - семинар - група 1 - седмица 7

## Задачи за упражнение с двоични дървета

### Задача 0

Модифицирайте дадения клас [`Node`](../05_linked_list/solutions/Node.h) от по-предната седмица, така че той да представя възел от двоично дърво. Не е нужно да имплементирате `add` и `print`, ако не ви потрябват в решенията.

### Задача 1

Реализирайте функция `void printLeftParentRight(const Node<T>* btree)`, която по подаден корен на двоично дърво `btree` принтира елементите му в ред ляво дете - родител - дясно дете.

```cpp
Вход:
Node<int> *btree = new Node<int>(1,
                               new Node<int>(2,
                                              new Node<int>(3),
                                              new Node<int>(4)),
                               new Node<int>(5,
                                              new Node<int>(6),
                                              new Node<int>(7)));

Изход:
3 2 4 1 6 5 7
```

### Задача 2

Да се напише функция `std::size_t findNodesNumber(Node<T> *btree)`, която по подаден корен на двоично дърво преброява колко възела има в дървото.

```cpp
Вход:
Node<int> *btree = new Node<int>(1,
                               new Node<int>(2,
                                              new Node<int>(3),
                                              new Node<int>(4)),
                               new Node<int>(5,
                                              new Node<int>(6),
                                              new Node<int>(7)));

Изход:
7
```

### Задача 3

Да се напише функция

```cpp
template <typename Type, typename Result>
Result accumulateBTree(
    const Node<Type> *btree,
    const std::function<Result(const Type&)>& transformValueFunc,
    const std::function<Result(const Result&, const Result&)>& accumulateFunc,
    const Result& initialValue
)
```

, която по подаден корен на двоично дърво, трансформираща стойността на възела функция, акумулираща функция и начална стойност(неутрална спрямо акумулиращата функция) връща получения резултат за цялото дърво.

```cpp
Пример:
Node<int> *btree = new Node<int>(1,
                           new Node<int>(2,
                                          new Node<int>(3),
                                          new Node<int>(4)),
                           new Node<int>(5,
                                          new Node<int>(6),
                                          new Node<int>(7)));
std::function<int(const int&)> squareFn = [] (const int& value) -> int {
    return value * value;
};
std::function<int(const int&, const int&)> sumFn = [] (
    const int& value1, const int& value2
) -> int {
    return value1 + value2;
};

std::cout << accumulateBTree(btree, squareFn, sumFn, 0) << std::endl;

Изход:
// 1*1 + 2*2 + 3*3 + 4*4 + 5*5 + 6*6 + 7*7
140
```

### Задача 4

Решете задача [**Tree: Huffman Decoding** в HackerRank](https://www.hackerrank.com/challenges/tree-huffman-decoding/problem).

## Задача за упражнение с дървета с произволен брой наследници

### Задача 5

Разглеждаме файлова система, в която има два вида файлове:

- **обикновени текстови файлове**, които се характеризират с име и размер в байтове;
- **директории**, които също имат име и съдържат множество файлове в себе си.

Моделирайте файловата система, използвайки дървовидна структура, която има корен `/`, в *C++*, така че да са възможни следните операции:

А) **Добавяне на файл** -- по зададено име (път), където да бъде добавен, и вид (директория или текстов). Например `/home/stoyan/Documents/test.txt` за текстов файл или `/etc/sshd` за директория.

Да се реализира възможност за избор дали несъществуващите директории по пътя да бъдат създавани, когато се добавя директория: Ако се избере да, то всички директории по пътя биват създадени, ако те не съществуват. В противен случай, да се хвърли изключение и файлът да не бъде добавян, ако има несъществуващи.

Да се хвърли изключение и когато пътят е невалиден: Добяване на текстови файл в несъществуваща директория, добавяне на файл като дете на текстови файл и така нататък.

Б) **Премахване на файл** -- по зададен път, например `/home/stoyan/Documents/test.txt`.

Реализирайте възможност за избор дали съдържанието да бъде изтривано при премахване на директория: Ако се избере да, то се премахва директорията и съдържанието ѝ, в противен случай състоянието не се променя, като се хвърля подходящо изключение.

Да се хвърли изключение и когато пътят е невалиден.

В) **Извеждане на файловете**, в зададен формат: На първия ред е коренът на файловата система, а всички негови подфайлове да се извеждат отместени наляво с табулация. По същия начин за останалите директории и файлове.

Пример:

```
/   // Това е коренът на файловата система
    Общи
        Седмица_02
            README.md
            solutions
                task_01
                    DynArrayBool.inl
                    README.md
                    test.cpp
        Седмица_03
            README.md
            solutions
                task01.cpp
                task02.cpp
                task03.cpp
                task04.cpp
                task05.cpp
                task06.cpp
                task07.cpp
    ... // Премахнато за краткост
```

Г) **Извеждане на файловете**, заедно с техните **размери**: За обикновени файлове, това е размерът им, а за директории -- сумата от размерите на файловете в тях. Форматът да бъде подобен на В), като до името на файла се извежда и неговия размер, но редът на извеждане е „обърнат“, тоест коренът и съответно сборът на всички размери е последен.
