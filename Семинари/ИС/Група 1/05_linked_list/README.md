# СД на ИС - семинар - група 1 - седмица 5

## Задачи за упражнение с (линеен едно)свързан списък

Условията предполагат използване на следното представяне на възел от свързан списък:

```cpp
template <typename T>
struct Node {
    T value;  // Стойност, съхранена във възела.
    Node<T>* next; // Указател към евентуалния следващ елемент.

    Node(T value = T(), Node* next = nullptr)
      : value(value), next(next)
    { }
};
```

Ако предпочитате да използвате `std::forward_list` или дефиницията на списък от часа, необходимо е
да промените съответно декларациите на функциите.
Не може да използвате готови имплементации на съответните функции, където има такива.

### Задача 1

Дефинирайте функция `unsigned int countOf(const Node<T>* list, const T& value)`, която връща броя на
срещанията на `value` в списъка с начало `list`.

### Задача 2

Дефинирайте функция `Node<T>* removeAll(Node<T>* list, const T& value)`, която премахва всички
срещания на `value` от списъка с начало `list` и връща началото на така получения списък.

### Задача 3

Дефинирайте функция `Node<T>* removeKth(Node<T>* list, size_t k)`, която премахва всеки k-ти елемент
от списъка с начало `list` и връща началото на така получения списък.

```cpp
Вход:
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7
k = 3
Изход:
1 -> 2 -> 4 -> 5 -> 7
```

### Задача 4

Да се напише функция `Node<T>* reverse(Node<T>* list)`, която обръща списъка с начало `list` и връща
новото му начало.

### Задача 5

Реализирайте функция `Node<T>* cloneReversed(const Node<T>* first)`, която:

1. Получава указател към първия елемент на свързан списък. Този списък не бива да бъде променян.
2. Създава нов списък, който съхранява същите стойности, но наредени в обратен ред. Например, ако
първоначалният списък има вида

1 -> 2 -> 3 -> 4 -> 5

, функцията създава копие, което има вида

5 -> 4 -> 3 -> 2 -> 1

Паметта за кутиите на новия списък да се заделя с `new`. Ако по време на копирането някое от
заделянията на памет не успее, функцията трябва да почисти паметта, преди да прекрати своята работа;
не бива да се допуска изтичане на памет. В този случай функкцията трябва да хвърли изключение от тип
`std::bad_alloc`.

3. Връща началото на новия списък. Ако `first` е `nullptr`, функцията да връща `nullptr`.
