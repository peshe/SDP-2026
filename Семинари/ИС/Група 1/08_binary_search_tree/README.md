# СД на ИС - семинар - група 1 - седмица 8

## Задачи за упражнение с двоични дървета за търсене

### Задача 1

Дефинирайте функция `isBST`, която по подаден указател към
[корен на двоично дърво](../07_tree/solutions/Node.h) проверява дали това дърво е двоично дърво
за търсене.

### Задача 2

Напишете функция `isBalanced`, която проверява дали дадено ДДТ е балансирано.
Едно ДДТ е балансирано, ако:

- е празно, или
- лявото му и дясното му поддърво са балансирани и разликата между височините на лявото и дясното
поддърво е 0 или 1.

### Задача 3

Реализирайте функция за записване на двоично дърво за търсене в `std::vector`.

### Задача 4

Реализирайте функция, която по даден *сортиран* `std::vector` създава двоично дърво за търсене.

*Балансирано* ли е полученото дърво? Модифицирайте решението си, така че дървото да е балансирано
ДДТ.

### Задача 5

Използвайте класа `std::set`, за да имплементирате ефективно следните функции:

- `int countUniques(const std::vector<int>& data)` - връща броя на уникланите елементи във вектора;
- `bool twoSum(const std::vector<int>& data, int target)` - връща истина <=> съществуват два елемента
във вектора, чиято сума е равна на `target`.
